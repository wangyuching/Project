opencv toturin

https://youtu.be/xjrykYpaBBM?si=3WutwCjxh0x5CHir&t=6197

import cv2

img = cv2.imread('test.png')
print(img.shape)
#    (700, 960, 3) (高、Y軸、row, 寬、X軸、col, 3原色)

-----------------------------------

檢視圖片:
import cv2
img = cv2.imread('735.png')

# 調整圖片大小, (哪張圖片, (寬, 高))
# img = cv2.resize(img, (600, 400))
#倍數縮放
img = cv2.resize(img, (0, 0), fx=0.5, fy=0.5)

cv2.imshow('head_line', img)
cv2.waitKey(0) # 任意鍵按下才關

-------------------------------

# 播放影片文件
import cv2
cap = cv2.VideoCapture('111.mp4')

while True:
    ret, frame = cap.read()
    if ret:
        frame = cv2.resize(frame, (0, 0), fx=0.5, fy=0.5)
        cv2.imshow('Frame', frame)

    else:
        break
    # 影片慢, 值改大
    if cv2.waitKey(30) == ord('q'):
        break

---------------------------------------

# 創建一張馬賽克圖片
import cv2
import numpy as np
import random

# 創建多為陣列, ((300px*500px, RGB), 正整數的顏色0~255以二進制表示 )
img = np.empty((300, 500, 3), np.uint8)

for row in range(300):
    for col in range(500):
        img[row][col] = [random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)] # B, G, R

cv2.imshow('image', img)
cv2.waitKey(0)

---------------------------

# 把圖片的固定高、圖片寬設為馬賽克
import cv2
import numpy as np
import random

img = cv2.imread('test.png')

for row in range(300):
    for col in range(img.shape[1]):
        img[row][col] = [random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)] # B, G, R

cv2.imshow('image', img)
cv2.waitKey(0)

---------------------------

# 擷取原圖 Y:0~150, X:0~200 的區域
import cv2
import numpy as np
import random

img = cv2.imread('test.png')

# 擷取原圖 Y:0~150, X:0~200 的區域
new_img = img[:150, :200]

# 擷取原圖 Y:320~600, X:550~920 的區域
new_img = img[320:600, 550:920]

cv2.imshow('image', img)
cv2.imshow('new_image', new_img)
cv2.waitKey(0)

-----------------------------------

# 把圖片的自訂高、寬設為馬賽克
import cv2
import numpy as np
import random

img = cv2.imread('test.png')

for row in range(300, 600):
    for col in range(550, 920):
        img[row][col] = [random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)] # B, G, R

cv2.imshow('image', img)
cv2.waitKey(0)

--------------------------------------
#cv2常用函式
import cv2
import numpy as np

# 預設值為 1 的二維陣列, 高3 * 寬3, 0~255以二進位制表示
kernel = np.ones((8, 8), np.uint8)

img = cv2.imread('test.png')
img = cv2.resize(img, (0, 0), fx=0.5, fy=0.5)

#BGR to GRAY
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Gaussian Blur(img, 模模點大小「限制奇數」, 標準差)
blur = cv2.GaussianBlur(img, (5, 5), 0)

# 圖片上的每個px值打分(與周圍px值的差別大小, 差別越大, 分越高) 
# Canny(img, 低於數值-過濾, 高於數值-接受)
canny = cv2.Canny(img, 15, 20)

# 膨脹(讓邊緣線條更粗)
dilated = cv2.dilate(canny, kernel, iterations=1)

# 侵蝕(讓邊緣線條更細)
eroded = cv2.erode(dilated, kernel, iterations=1)  

# cv2.imshow('original', img)
# cv2.imshow('gray', gray)
# cv2.imshow('blur', blur)
# cv2.imshow('canny', canny) 
cv2.imshow('dilated', dilated)
cv2.imshow('eroded', eroded)
cv2.waitKey(0)

------------------------------

# 寫字、畫圖
import cv2
import numpy as np

# 建立一個Y高600, X寬300, 顏色預設值維 0 的黑色背景的圖片
img = np.zeros((600, 300, 3), np.uint8)  

# 畫線 (圖片, 起點座標, 終點座標, 顏色BGR, 線條粗細)
cv2.line(img, (0, 0), (img.shape[1], img.shape[0]), (255, 0, 0), 5)  
# 矩形 (圖片, 左上角座標, 右下角座標, 顏色BGR, 線條粗細/填滿)
cv2.rectangle(img, (50, 50), (250, 150), (0, 0, 255), cv2.FILLED)  
# 圓形 (圖片, 圓心座標, 半徑, 顏色BGR, 線條粗細/填滿)
cv2.circle(img, (150, 300), 75, (0, 255, 0), cv2.FILLED)
# 文字 (圖片, 文字內容, 文字起始座標, 字型, 字型大小, 顏色BGR, 線條粗細)
cv2.putText(img, 'Hello', (50, 500), cv2.FONT_HERSHEY_COMPLEX, 1, (255, 255, 255), 3)

cv2.imshow('img', img)
cv2.waitKey(0)

-------------------------------

# 找顏色
import cv2
import numpy as np

def empty(v):
    pass

img = cv2.imread('test.png')
img = cv2.resize(img, (0, 0), fx=0.5, fy=0.5)

cv2.namedWindow('trackbar')
cv2.resizeWindow('trackbar', 500, 350)

# 建立六個軌跡條來調整HSV的範圍(名稱, 視窗名稱, 預設值, 最大值, 回調函數)
cv2.createTrackbar('Hue_Min', 'trackbar', 0, 179, empty)
cv2.createTrackbar('Hue_Max', 'trackbar', 179, 179, empty)
cv2.createTrackbar('Sat_Min', 'trackbar', 0, 255, empty)
cv2.createTrackbar('Sat_Max', 'trackbar', 255, 255, empty)
cv2.createTrackbar('Val_Min', 'trackbar', 0, 255, empty)
cv2.createTrackbar('Val_Max', 'trackbar', 255, 255, empty)

# hsv:色調、飽和度、亮度
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
while True:
    h_min = cv2.getTrackbarPos('Hue_Min', 'trackbar')
    h_max = cv2.getTrackbarPos('Hue_Max', 'trackbar')
    s_min = cv2.getTrackbarPos('Sat_Min', 'trackbar')
    s_max = cv2.getTrackbarPos('Sat_Max', 'trackbar')
    v_min = cv2.getTrackbarPos('Val_Min', 'trackbar')
    v_max = cv2.getTrackbarPos('Val_Max', 'trackbar')
    print(h_min, h_max, s_min, s_max, v_min, v_max)

    lower = np.array([h_min, s_min, v_min])
    upper = np.array([h_max, s_max, v_max])

    mask = cv2.inRange(hsv, lower, upper)
    result = cv2.bitwise_and(img, img, mask=mask)

    cv2.imshow('img', img)
    cv2.imshow('hsv', hsv)
    cv2.imshow('mask', mask)
    cv2.imshow('result', result)
    cv2.waitKey(1)

---------------------------------------------------

# 找輪廓
import cv2
import numpy as np

img = cv2.imread('test.png')
img_contours = img.copy()
img = cv2.resize(img, (0, 0), fx=0.5, fy=0.5)
img_contours = cv2.resize(img_contours, (0, 0), fx=0.5, fy=0.5)
img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
canny = cv2.Canny(img, 150, 200)
# 偵測輪廓:輪廓, 階層 = (邊緣圖片, 輪廓檢索模式, 輪廓近似方法)
contours, hierarchy = cv2.findContours(canny, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)

for cnt in contours:
    cv2.drawContours(img_contours, cnt, -1, (255, 0, 0), 2)
    # 輪廓面積
    print(cv2.contourArea(cnt))
    # 輪廓周長
    print(cv2.arcLength(cnt, True))

cv2.imshow('img', img)
cv2.imshow('canny', canny)
cv2.imshow('contours', img_contours)
cv2.waitKey(0)

----------------------------------------

# 輪廓近似(多邊形印似 > 推測輪廓形狀)
import cv2
import numpy as np

img = cv2.imread('shape.png')
img_contours = img.copy()
img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
canny = cv2.Canny(img, 150, 200)
# 偵測輪廓:輪廓, 階層 = (邊緣圖片, 輪廓檢索模式, 輪廓近似方法)
contours, hierarchy = cv2.findContours(canny, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)

for cnt in contours:
    cv2.drawContours(img_contours, cnt, -1, (255, 0, 0), 2)
    area = cv2.contourArea(cnt)
    if area > 500:
        peri = cv2.arcLength(cnt, True)
        vertices = cv2.approxPolyDP(cnt, peri * 0.02, True) 
        corners = (len(vertices))
        left_top_x, lest_top_y, w, h = cv2.boundingRect(vertices)
        cv2.rectangle(img_contours, (left_top_x, lest_top_y), (left_top_x + w, lest_top_y + h), (0, 255, 0), 2)
        if corners == 3:
            cv2.putText(img_contours, 'Triangle', (left_top_x, lest_top_y - 5), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)
        elif corners == 4:
            cv2.putText(img_contours, 'Retengle', (left_top_x, lest_top_y - 5), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)
        elif corners == 5:
            cv2.putText(img_contours, 'Pentagon', (left_top_x, lest_top_y - 5), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)
        elif corners >= 6:
            cv2.putText(img_contours, 'Circle', (left_top_x, lest_top_y - 5), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)


cv2.imshow('img', img)
cv2.imshow('canny', canny)
cv2.imshow('contours', img_contours)
cv2.waitKey(0)

--------------------------------------------

#圖片人臉辨識
import cv2

img = cv2.imread('face.png')

gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
face_cascade = cv2.CascadeClassifier('face_detect.xml')
face_rect = face_cascade.detectMultiScale(gray, 2, 3)
print(len(face_rect))

for (x, y, w, h) in face_rect:
    cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 2)

cv2.imshow('Image', img)
cv2.waitKey(0)

----------------------------------


